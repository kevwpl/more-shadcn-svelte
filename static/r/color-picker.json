{
	"$schema": "https://shadcn-svelte.com/schema/registry-item.json",
	"name": "color-picker",
	"title": "Color Picker",
	"type": "registry:ui",
	"description": "A mobile-first bottom navigation bar.",
	"dependencies": [
		"lucide-svelte@^0.554.0"
	],
	"registryDependencies": [
		"button",
		"button-group",
		"command",
		"popover",
		"input"
	],
	"files": [
		{
			"content": "<!-- $lib/components/ui/color-picker/color-picker.svelte -->\r\n<script lang=\"ts\">\r\n    import { cn } from '$UTILS$';\r\n    import { Button } from '$lib/components/ui/button';\r\n    import { ChevronDown } from 'lucide-svelte';\r\n    import * as Popover from \"$lib/components/ui/popover\";\r\n    import * as Command from \"$lib/components/ui/command\";\r\n    import * as ButtonGroup from \"$lib/components/ui/button-group\";\r\n    import { Input } from \"$lib/components/ui/input\";\r\n\r\n    type ColorFormat = 'hex' | 'rgb' | 'hsl' | 'oklch';\r\n\r\n    let {\r\n        value = $bindable('#000000'),\r\n        class: className,\r\n        allowOpacity = false,\r\n        defaultFormat = 'hex',\r\n        formats = ['hex', 'rgb', 'hsl', 'oklch']\r\n    }: {\r\n        value?: string;\r\n        class?: string;\r\n        allowOpacity?: boolean;\r\n        defaultFormat?: ColorFormat;\r\n        formats?: ColorFormat[];\r\n    } = $props();\r\n\r\n    let h = $state(0);\r\n    let s = $state(0);\r\n    let v = $state(0);\r\n    let a = $state(1);\r\n    let activeFormat = $state<ColorFormat>(defaultFormat);\r\n    let isDragging = $state(false);\r\n\r\n    let sbRef: HTMLDivElement | undefined = $state();\r\n    let hueRef: HTMLDivElement | undefined = $state();\r\n    let alphaRef: HTMLDivElement | undefined = $state();\r\n    let formatOpen = $state(false);\r\n\r\n    $effect(() => {\r\n        if (!isDragging) {\r\n            const parsed = parseColor(value);\r\n            if (parsed) {\r\n                const currentStr = formatOutput(h,s,v,a, activeFormat);\r\n                const parsedStr = formatOutput(parsed.h, parsed.s, parsed.v, parsed.a, activeFormat);\r\n\r\n                if (currentStr !== parsedStr) {\r\n                    h = parsed.h; s = parsed.s; v = parsed.v; a = parsed.a;\r\n                    if (value.startsWith('rgb')) activeFormat = 'rgb';\r\n                    else if (value.startsWith('hsl')) activeFormat = 'hsl';\r\n                    else if (value.startsWith('oklch')) activeFormat = 'oklch';\r\n                    else activeFormat = 'hex';\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    function updateExternal() {\r\n        value = formatOutput(h, s, v, a, activeFormat);\r\n    }\r\n\r\n    function setFormat(fmt: ColorFormat) {\r\n        activeFormat = fmt;\r\n        updateExternal();\r\n        formatOpen = false;\r\n    }\r\n\r\n    // --- Math & Parsing ---\r\n\r\n    function parseColor(str: string) {\r\n        str = str.trim().toLowerCase();\r\n        if (str.startsWith('#')) {\r\n            let hex = str.replace('#', '');\r\n            let r = 0, g = 0, b = 0, alpha = 1;\r\n            if (hex.length === 3) {\r\n                r = parseInt(hex[0] + hex[0], 16); g = parseInt(hex[1] + hex[1], 16); b = parseInt(hex[2] + hex[2], 16);\r\n            } else if (hex.length === 6) {\r\n                r = parseInt(hex.substring(0, 2), 16); g = parseInt(hex.substring(2, 4), 16); b = parseInt(hex.substring(4, 6), 16);\r\n            } else if (hex.length === 8) {\r\n                r = parseInt(hex.substring(0, 2), 16); g = parseInt(hex.substring(2, 4), 16); b = parseInt(hex.substring(4, 6), 16);\r\n                alpha = parseInt(hex.substring(6, 8), 16) / 255;\r\n            }\r\n            return { ...rgbToHsv(r, g, b), a: alpha };\r\n        }\r\n        if (str.startsWith('rgb')) {\r\n            const values = str.match(/[\\d.]+/g)?.map(Number);\r\n            if (values && values.length >= 3) return { ...rgbToHsv(values[0], values[1], values[2]), a: values[3] ?? 1 };\r\n        }\r\n        if (str.startsWith('hsl')) {\r\n            const values = str.match(/[\\d.]+/g)?.map(Number);\r\n            if (values && values.length >= 3) {\r\n                const sNorm = values[1] / 100, lNorm = values[2] / 100;\r\n                let vNorm = lNorm + sNorm * Math.min(lNorm, 1 - lNorm);\r\n                let sHsv = vNorm === 0 ? 0 : 2 * (1 - lNorm / vNorm);\r\n                return { h: values[0], s: sHsv * 100, v: vNorm * 100, a: values[3] ?? 1 };\r\n            }\r\n        }\r\n        if (str.startsWith('oklch')) {\r\n            const values = str.match(/[\\d.%]+/g)?.map(s => s.includes('%') ? parseFloat(s) / 100 : parseFloat(s));\r\n            if (values && values.length >= 3) {\r\n                const rgb = oklchToRgb(values[0], values[1], values[2]);\r\n                return { ...rgbToHsv(rgb.r, rgb.g, rgb.b), a: values[3] ?? 1 };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    function formatOutput(h: number, s: number, v: number, a: number, format: ColorFormat): string {\r\n        if (format === 'hex') return hsvToHex(h, s, v, a);\r\n        if (format === 'rgb') return hsvToRgbString(h, s, v, a);\r\n        if (format === 'hsl') return hsvToHslString(h, s, v, a);\r\n        if (format === 'oklch') return hsvToOklchString(h, s, v, a);\r\n        return '';\r\n    }\r\n\r\n    // --- Color Conversions ---\r\n\r\n    function rgbToHsv(r: number, g: number, b: number) {\r\n        r /= 255; g /= 255; b /= 255;\r\n        const max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n        let h = 0, s = 0, v = max;\r\n        const d = max - min;\r\n        s = max === 0 ? 0 : d / max;\r\n        if (max !== min) {\r\n            switch (max) {\r\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\r\n                case g: h = (b - r) / d + 2; break;\r\n                case b: h = (r - g) / d + 4; break;\r\n            }\r\n            h /= 6;\r\n        }\r\n        return { h: h * 360, s: s * 100, v: v * 100 };\r\n    }\r\n\r\n    function hsvToRgb(h: number, s: number, v: number) {\r\n        let sNorm = s / 100, vNorm = v / 100;\r\n        let r = 0, g = 0, b = 0;\r\n        const i = Math.floor(h / 60), f = h / 60 - i, p = vNorm * (1 - sNorm), q = vNorm * (1 - f * sNorm), t = vNorm * (1 - (1 - f) * sNorm);\r\n        switch (i % 6) {\r\n            case 0: r = vNorm; g = t; b = p; break;\r\n            case 1: r = q; g = vNorm; b = p; break;\r\n            case 2: r = p; g = vNorm; b = t; break;\r\n            case 3: r = p; g = q; b = vNorm; break;\r\n            case 4: r = t; g = p; b = vNorm; break;\r\n            case 5: r = vNorm; g = p; b = q; break;\r\n        }\r\n        return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };\r\n    }\r\n\r\n    // OKLCH Logic\r\n    function hsvToOklchString(h: number, s: number, v: number, a: number) {\r\n        const rgb = hsvToRgb(h,s,v);\r\n        const oklch = rgbToOklch(rgb.r, rgb.g, rgb.b);\r\n        const L = (oklch.l * 100).toFixed(1) + \"%\";\r\n        const C = oklch.c.toFixed(3);\r\n        const H = (oklch.h || 0).toFixed(1);\r\n\r\n        if (allowOpacity && a < 1) return `oklch(${L} ${C} ${H} / ${parseFloat(a.toFixed(2))})`;\r\n        return `oklch(${L} ${C} ${H})`;\r\n    }\r\n\r\n    function rgbToOklch(r: number, g: number, b: number) {\r\n        r/=255; g/=255; b/=255;\r\n        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\r\n        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\r\n        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\r\n\r\n        const l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;\r\n        const m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;\r\n        const s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;\r\n\r\n        const l_ = Math.cbrt(l), m_ = Math.cbrt(m), s_ = Math.cbrt(s);\r\n\r\n        const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;\r\n        const A = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;\r\n        const B = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;\r\n\r\n        const C = Math.sqrt(A * A + B * B);\r\n        let H = (Math.atan2(B, A) * 180) / Math.PI;\r\n        if (H < 0) H += 360;\r\n\r\n        return { l: L, c: C, h: H };\r\n    }\r\n\r\n    function oklchToRgb(l: number, c: number, h: number) {\r\n        const hRad = h * (Math.PI / 180);\r\n        const A = c * Math.cos(hRad);\r\n        const B = c * Math.sin(hRad);\r\n        const L = l;\r\n\r\n        const l_ = L + 0.3963377774 * A + 0.2158037573 * B;\r\n        const m_ = L - 0.1055613458 * A - 0.0638541728 * B;\r\n        const s_ = L - 0.0894841775 * A - 1.2914855480 * B;\r\n\r\n        const lLin = l_ * l_ * l_;\r\n        const mLin = m_ * m_ * m_;\r\n        const sLin = s_ * s_ * s_;\r\n\r\n        let r = +4.0767416621 * lLin - 3.3077115913 * mLin + 0.2309699292 * sLin;\r\n        let g = -1.2684380046 * lLin + 2.6097574011 * mLin - 0.3413193965 * sLin;\r\n        let b = -0.0041960863 * lLin - 0.7034186147 * mLin + 1.7076147010 * sLin;\r\n\r\n        r = r >= 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : 12.92 * r;\r\n        g = g >= 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : 12.92 * g;\r\n        b = b >= 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : 12.92 * b;\r\n\r\n        r = Math.min(Math.max(0, r), 1) * 255;\r\n        g = Math.min(Math.max(0, g), 1) * 255;\r\n        b = Math.min(Math.max(0, b), 1) * 255;\r\n        return { r, g, b };\r\n    }\r\n\r\n    function hsvToHex(h: number, s: number, v: number, a: number) {\r\n        const { r, g, b } = hsvToRgb(h, s, v);\r\n        const toHex = (x: number) => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; };\r\n        let hex = `#${toHex(r)}${toHex(g)}${toHex(b)}`;\r\n        if (allowOpacity && a < 1) hex += toHex(Math.round(a * 255));\r\n        return hex.toUpperCase();\r\n    }\r\n\r\n    function hsvToRgbString(h: number, s: number, v: number, a: number) {\r\n        const { r, g, b } = hsvToRgb(h, s, v);\r\n        if (allowOpacity && a < 1) return `rgba(${r}, ${g}, ${b}, ${parseFloat(a.toFixed(2))})`;\r\n        return `rgb(${r}, ${g}, ${b})`;\r\n    }\r\n\r\n    function hsvToHslString(h: number, s: number, v: number, a: number) {\r\n        const sNorm = s / 100, vNorm = v / 100;\r\n        let l = (2 - sNorm) * vNorm / 2;\r\n        let sHsl = l && l < 1 ? sNorm * vNorm / (l < 0.5 ? l * 2 : 2 - l * 2) : sNorm;\r\n        if (allowOpacity && a < 1) return `hsla(${Math.round(h)}, ${Math.round(sHsl * 100)}%, ${Math.round(l * 100)}%, ${parseFloat(a.toFixed(2))})`;\r\n        return `hsl(${Math.round(h)}, ${Math.round(sHsl * 100)}%, ${Math.round(l * 100)}%)`;\r\n    }\r\n\r\n    // --- Interaction Helpers ---\r\n\r\n    function handleDragStart(e: MouseEvent | TouchEvent, fn: (e: MouseEvent | TouchEvent) => void) {\r\n        isDragging = true;\r\n        fn(e);\r\n        const move = (e: MouseEvent | TouchEvent) => fn(e);\r\n        const stop = () => {\r\n            isDragging = false;\r\n            window.removeEventListener('mousemove', move); window.removeEventListener('touchmove', move);\r\n            window.removeEventListener('mouseup', stop); window.removeEventListener('touchend', stop);\r\n        };\r\n        window.addEventListener('mousemove', move); window.addEventListener('touchmove', move);\r\n        window.addEventListener('mouseup', stop); window.addEventListener('touchend', stop);\r\n    }\r\n\r\n    function handleSbChange(e: MouseEvent | TouchEvent) {\r\n        if (!sbRef) return;\r\n        const rect = sbRef.getBoundingClientRect();\r\n        const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\r\n        const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\r\n        const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));\r\n        const y = Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));\r\n        s = x * 100; v = (1 - y) * 100; updateExternal();\r\n    }\r\n\r\n    function handleHueChange(e: MouseEvent | TouchEvent) {\r\n        if (!hueRef) return;\r\n        const rect = hueRef.getBoundingClientRect();\r\n        const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\r\n        const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));\r\n        h = x * 360; updateExternal();\r\n    }\r\n\r\n    function handleAlphaChange(e: MouseEvent | TouchEvent) {\r\n        if (!alphaRef) return;\r\n        const rect = alphaRef.getBoundingClientRect();\r\n        const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\r\n        const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));\r\n        a = Math.round(x * 100) / 100; updateExternal();\r\n    }\r\n\r\n    // --- Inputs ---\r\n\r\n    function handleAlphaInput(e: Event & { currentTarget: HTMLInputElement }) {\r\n        let val = parseInt(e.currentTarget.value);\r\n        if (isNaN(val)) return;\r\n        val = Math.max(0, Math.min(100, val));\r\n        a = val / 100;\r\n        updateExternal();\r\n    }\r\n</script>\r\n\r\n<div class={cn(\"flex w-[350px] flex-col gap-3 p-3 border rounded-lg shadow-sm bg-popover\", className)}>\r\n    <!-- 1. Saturation Box -->\r\n    <div\r\n            bind:this={sbRef}\r\n            class=\"relative h-56 w-full cursor-crosshair rounded-md shadow-sm overflow-hidden touch-none\"\r\n            style:background-color={`hsl(${h}, 100%, 50%)`}\r\n            role=\"slider\"\r\n            aria-label=\"Saturation and Brightness\"\r\n            aria-valuenow={s}\r\n            tabindex=\"0\"\r\n            onmousedown={(e) => handleDragStart(e, handleSbChange)}\r\n            ontouchstart={(e) => handleDragStart(e, handleSbChange)}\r\n    >\r\n        <div class=\"absolute inset-0 bg-gradient-to-r from-white to-transparent pointer-events-none\" />\r\n        <div class=\"absolute inset-0 bg-gradient-to-t from-black to-transparent pointer-events-none\" />\r\n        <div class=\"absolute h-3 w-3 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 border-white shadow-sm ring-1 ring-black/20 pointer-events-none\" style:left={`${s}%`} style:top={`${100 - v}%`} />\r\n    </div>\r\n\r\n    <!-- 2. Mid: Preview + Sliders -->\r\n    <div class=\"flex gap-3 items-center\">\r\n        <!-- Static Preview -->\r\n        <div class=\"h-8 w-8 shrink-0 rounded-md border shadow-sm relative overflow-hidden mt-1 bg-[url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWAAJyRCgLaBCAAgXwixzAS0pgAAAABJRU5ErkJggg==')]\">\r\n            <div class=\"absolute inset-0\" style:background-color={hsvToHex(h,s,v,a)} />\r\n        </div>\r\n\r\n        <div class=\"flex flex-1 flex-col gap-3 justify-center\">\r\n            <!-- Hue -->\r\n            <div\r\n                    bind:this={hueRef}\r\n                    class=\"relative h-3 w-full cursor-pointer rounded-full shadow-sm ring-1 ring-black/5 touch-none\"\r\n                    style:background=\"linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%)\"\r\n                    role=\"slider\" aria-valuenow={h} tabindex=\"0\"\r\n                    onmousedown={(e) => handleDragStart(e, handleHueChange)} ontouchstart={(e) => handleDragStart(e, handleHueChange)}\r\n            >\r\n                <div class=\"absolute top-1/2 h-3 w-3 -translate-x-1/2 -translate-y-1/2 rounded-full bg-white pointer-events-none\" style:left={`${(h / 360) * 100}%`} />\r\n            </div>\r\n\r\n            <!-- Alpha -->\r\n            {#if allowOpacity}\r\n                <div\r\n                        bind:this={alphaRef}\r\n                        class=\"relative h-3 w-full cursor-pointer rounded-full shadow-sm ring-1 ring-black/5 touch-none bg-[url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWAAJyRCgLaBCAAgXwixzAS0pgAAAABJRU5ErkJggg==')]\"\r\n                        role=\"slider\" aria-valuenow={a} tabindex=\"0\"\r\n                        onmousedown={(e) => handleDragStart(e, handleAlphaChange)} ontouchstart={(e) => handleDragStart(e, handleAlphaChange)}\r\n                >\r\n                    <div class=\"absolute inset-0 rounded-full\" style:background={`linear-gradient(to right, transparent, ${hsvToHex(h,s,v,1)})`} />\r\n                    <div class=\"absolute top-1/2 h-3 w-3 -translate-x-1/2 -translate-y-1/2 rounded-full bg-white pointer-events-none\" style:left={`${a * 100}%`} />\r\n                </div>\r\n            {/if}\r\n        </div>\r\n    </div>\r\n\r\n    <!-- 3. Bottom: Controls -->\r\n    <ButtonGroup.Root class=\"w-full\">\r\n        {#if formats.length > 1}\r\n        <Popover.Root bind:open={formatOpen}>\r\n            <Popover.Trigger>\r\n                {#snippet child({ props })}\r\n                    <Button {...props} variant=\"outline\" class=\"max-w-[5rem] px-2 text-[10px] justify-between h-9\">\r\n                        {activeFormat.toUpperCase()}\r\n                        <ChevronDown class=\"h-3 w-3 opacity-50\" />\r\n                    </Button>\r\n                {/snippet}\r\n            </Popover.Trigger>\r\n            <Popover.Content class=\"w-[4.5rem] p-0\" align=\"start\">\r\n                <Command.Root>\r\n                    <Command.List>\r\n                        <Command.Group>\r\n                            {#each ['hex', 'rgb', 'hsl', 'oklch'] as fmt}\r\n                                <Command.Item value={fmt} onSelect={() => setFormat(fmt as ColorFormat)} class=\"text-[10px] h-7 flex justify-center\">\r\n                                    {fmt.toUpperCase()}\r\n                                </Command.Item>\r\n                            {/each}\r\n                        </Command.Group>\r\n                    </Command.List>\r\n                </Command.Root>\r\n            </Popover.Content>\r\n        </Popover.Root>\r\n        {:else}\r\n            <Button variant=\"outline\" class=\"max-w-[5rem] px-2 text-[10px] justify-between h-9\">\r\n                {activeFormat.toUpperCase()}\r\n            </Button>\r\n        {/if}\r\n        <Input\r\n                class=\"h-9 font-mono text-[10px] uppercase flex-1\"\r\n                value={value}\r\n                oninput={(e) => {\r\n                    const parsed = parseColor(e.currentTarget.value);\r\n                    if (parsed) { h = parsed.h; s = parsed.s; v = parsed.v; a = parsed.a; updateExternal(); }\r\n                }}\r\n        />\r\n\r\n        {#if allowOpacity}\r\n            <Input\r\n                    class=\"h-9 font-mono text-[10px] text-right max-w-[4.2rem]\"\r\n                    value={Math.round(a * 100) + \"%\"}\r\n                    oninput={handleAlphaInput}\r\n                    maxlength={3}\r\n            />\r\n        {/if}\r\n    </ButtonGroup.Root>\r\n</div>",
			"type": "registry:ui",
			"target": "color-picker/color-picker.svelte"
		},
		{
			"content": "import ColorPicker from \"./color-picker.svelte\";\r\n\r\nexport { ColorPicker as Root };",
			"type": "registry:ui",
			"target": "color-picker/index.ts"
		}
	]
}