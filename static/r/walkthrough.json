{
	"$schema": "https://shadcn-svelte.com/schema/registry-item.json",
	"name": "walkthrough",
	"title": "Walkthrough",
	"type": "registry:ui",
	"description": "A guided tour component with spotlight and popover.",
	"dependencies": [
		"@floating-ui/dom"
	],
	"devDependencies": [
		"@lucide/svelte@^0.544.0"
	],
	"registryDependencies": [
		"button"
	],
	"files": [
		{
			"content": "<script lang=\"ts\">\r\n    import { setWalkthroughContext, type Step } from \"./ctx\";\r\n    import WalkthroughSpotlight from \"./walkthrough-spotlight.svelte\";\r\n    import WalkthroughContent from \"./walkthrough-content.svelte\";\r\n    import type { Snippet } from \"svelte\";\r\n\r\n    let {\r\n        steps = [],\r\n        open = $bindable(false),\r\n        onComplete,\r\n        children,\r\n        padding,\r\n    }: {\r\n        steps: Step[],\r\n        open: boolean,\r\n        onComplete?: () => void,\r\n        children?: Snippet<[any]>\r\n        padding?: number\r\n    } = $props();\r\n\r\n    let currentStepIndex = $state(0);\r\n    let highlightRect = $state({ top: 0, left: 0, width: 0, height: 0 }); // Removed 'fixed'\r\n\r\n    const isLastStep = $derived(currentStepIndex === steps.length - 1);\r\n    const currentStep = $derived(steps[currentStepIndex]);\r\n\r\n    function next() {\r\n        if (!isLastStep) currentStepIndex++;\r\n        else finish();\r\n    }\r\n\r\n    function prev() {\r\n        if (currentStepIndex > 0) currentStepIndex--;\r\n    }\r\n\r\n    function finish() {\r\n        open = false;\r\n        setTimeout(() => {\r\n            currentStepIndex = 0;\r\n            if(onComplete) onComplete();\r\n        }, 300);\r\n    }\r\n\r\n    setWalkthroughContext({\r\n        isOpen: () => open,\r\n        currentStepIndex: () => currentStepIndex,\r\n        currentStep: () => currentStep,\r\n        isLastStep: () => isLastStep,\r\n        next, prev, close: () => open = false\r\n    });\r\n</script>\r\n\r\n<WalkthroughSpotlight\r\n        open={open}\r\n        top={highlightRect.top}\r\n        left={highlightRect.left}\r\n        width={highlightRect.width}\r\n        height={highlightRect.height}\r\n/>\r\n\r\n{#if open && currentStep}\r\n    <WalkthroughContent\r\n            targetId={currentStep.target}\r\n            placement={currentStep.position}\r\n            onUpdateRect={(rect) => highlightRect = rect}\r\n            contentSnippet={children}\r\n            padding={padding}\r\n    />\r\n{/if}",
			"type": "registry:ui",
			"target": "walkthrough/walkthrough.svelte"
		},
		{
			"content": "<script lang=\"ts\">\r\n    import { onDestroy } from \"svelte\";\r\n    import { computePosition, autoUpdate, offset, shift, arrow, flip } from \"@floating-ui/dom\";\r\n    import { fade } from \"svelte/transition\";\r\n    import { getWalkthroughContext } from \"./ctx\";\r\n    import { Button } from \"$lib/components/ui/button\";\r\n    import { X } from \"@lucide/svelte\";\r\n    import type { Snippet } from \"svelte\";\r\n\r\n    let {\r\n        targetId,\r\n        placement = \"bottom\",\r\n        onUpdateRect,\r\n        contentSnippet,\r\n        padding = 0,\r\n    }: {\r\n        targetId: string,\r\n        placement?: \"top\" | \"bottom\" | \"left\" | \"right\",\r\n        onUpdateRect: (rect: {top: number, left: number, width: number, height: number}) => void,\r\n        contentSnippet?: Snippet<[any]>,\r\n        padding?: number,\r\n    } = $props();\r\n\r\n    const ctx = getWalkthroughContext();\r\n\r\n    let tooltipEl: HTMLElement;\r\n    let arrowEl: HTMLElement | undefined;\r\n    let cleanup: (() => void) | undefined;\r\n\r\n    // Track the final computed placement to rotate the arrow correctly\r\n    let actualPlacement = $state(placement);\r\n\r\n    function updateSpotlight(el: HTMLElement) {\r\n        const rect = el.getBoundingClientRect();\r\n        // Always send Viewport coordinates (fixed strategy)\r\n\r\n        const paddedWidth = rect.width + padding * 2;\r\n        const paddedHeight = rect.height + padding * 2;\r\n        const paddedTop = rect.top - padding;\r\n        const paddedLeft = rect.left - padding;\r\n\r\n        onUpdateRect({\r\n            top: paddedTop,\r\n            left: paddedLeft,\r\n            width: paddedWidth,\r\n            height: paddedHeight\r\n        });\r\n    }\r\n\r\n    function setupFloating() {\r\n        const targetEl = document.getElementById(targetId);\r\n        if (!targetEl || !tooltipEl) return;\r\n\r\n        updateSpotlight(targetEl);\r\n\r\n        const rect = targetEl.getBoundingClientRect();\r\n        const isVisible = (\r\n            rect.top >= 0 &&\r\n            rect.left >= 0 &&\r\n            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\r\n            rect.right <= (window.innerWidth || document.documentElement.clientWidth)\r\n        );\r\n\r\n        if (!isVisible) {\r\n            targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });\r\n        }\r\n\r\n        const middleware = [offset(12), flip(), shift({ padding: 10 })];\r\n        if (arrowEl) middleware.push(arrow({ element: arrowEl }));\r\n\r\n        cleanup = autoUpdate(targetEl, tooltipEl, () => {\r\n            updateSpotlight(targetEl);\r\n\r\n            computePosition(targetEl, tooltipEl, {\r\n                placement,\r\n                middleware,\r\n                strategy: 'fixed'\r\n            }).then(({ x, y, placement: finalPlacement, middlewareData }) => {\r\n                Object.assign(tooltipEl.style, {\r\n                    left: `${x}px`,\r\n                    top: `${y}px`,\r\n                    position: 'fixed',\r\n                    display: 'block'\r\n                });\r\n\r\n                // Update state for arrow rotation\r\n                actualPlacement = finalPlacement as any;\r\n\r\n                if (arrowEl && middlewareData.arrow) {\r\n                    const { x: arrowX, y: arrowY } = middlewareData.arrow;\r\n                    const staticSide = {\r\n                        top: \"bottom\", right: \"left\", bottom: \"top\", left: \"right\"\r\n                    }[finalPlacement.split(\"-\")[0]];\r\n\r\n                    Object.assign(arrowEl.style, {\r\n                        left: arrowX != null ? `${arrowX}px` : \"\",\r\n                        top: arrowY != null ? `${arrowY}px` : \"\",\r\n                        right: \"\", bottom: \"\",\r\n                        [staticSide as string]: \"-4px\"\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    $effect(() => {\r\n        if(targetId) {\r\n            if(cleanup) cleanup();\r\n            setTimeout(setupFloating, 10);\r\n        }\r\n    });\r\n\r\n    onDestroy(() => {\r\n        if (cleanup) cleanup();\r\n    });\r\n\r\n    // Calculate Arrow Rotation Classes\r\n    let arrowClasses = $derived.by(() => {\r\n        const side = actualPlacement.split(\"-\")[0];\r\n        const base = \"absolute h-2 w-2 rotate-45 bg-popover\";\r\n        // Top placement -> Arrow at bottom -> Points Down -> Border Bottom & Right\r\n        if (side === \"top\") return `${base} border-b border-r`;\r\n        // Bottom placement -> Arrow at top -> Points Up -> Border Top & Left\r\n        if (side === \"bottom\") return `${base} border-t border-l`;\r\n        // Left placement -> Arrow at right -> Points Right -> Border Top & Right\r\n        if (side === \"left\") return `${base} border-t border-r`;\r\n        // Right placement -> Arrow at left -> Points Left -> Border Bottom & Left\r\n        if (side === \"right\") return `${base} border-b border-l`;\r\n        return `${base} border-t border-l`;\r\n    });\r\n</script>\r\n\r\n<div\r\n        bind:this={tooltipEl}\r\n        role=\"dialog\"\r\n        class=\"fixed z-[9999] top-0 left-0 w-max outline-none\"\r\n        transition:fade={{ duration: 200 }}\r\n>\r\n    {#if contentSnippet}\r\n        {@render contentSnippet(ctx)}\r\n    {:else}\r\n        <div class=\"relative w-[350px] rounded-lg border bg-popover text-popover-foreground shadow-xl\">\r\n            <!-- Dynamic Arrow Classes -->\r\n            <div bind:this={arrowEl} class={arrowClasses}></div>\r\n\r\n            <div class=\"p-4\">\r\n                <div class=\"flex items-start justify-between gap-4\">\r\n                    <div class=\"space-y-1\">\r\n                        <h4 class=\"font-semibold leading-none\">{ctx.currentStep()?.title}</h4>\r\n                        <p class=\"text-sm text-muted-foreground\">{ctx.currentStep()?.description}</p>\r\n                    </div>\r\n                    <Button variant=\"ghost\" size=\"icon\" class=\"h-6 w-6 -mt-1 -mr-2 shrink-0\" onclick={ctx.close}>\r\n                        <X class=\"h-4 w-4\" />\r\n                    </Button>\r\n                </div>\r\n                <div class=\"flex items-center justify-between pt-4\">\r\n                    <span class=\"text-xs text-muted-foreground\">\r\n                        Step {ctx.currentStepIndex() + 1}\r\n                    </span>\r\n                    <div class=\"flex gap-2\">\r\n                        {#if ctx.currentStepIndex() > 0}\r\n                            <Button variant=\"outline\" size=\"sm\" onclick={ctx.prev}>Back</Button>\r\n                        {/if}\r\n                        <Button size=\"sm\" onclick={ctx.next}>\r\n                            {ctx.isLastStep() ? \"Finish\" : \"Next\"}\r\n                        </Button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    {/if}\r\n</div>",
			"type": "registry:ui",
			"target": "walkthrough/walkthrough-content.svelte"
		},
		{
			"content": "<script lang=\"ts\">\r\n    import { fade } from \"svelte/transition\";\r\n\r\n    let {\r\n        top = 0,\r\n        left = 0,\r\n        width = 0,\r\n        height = 0,\r\n        open = false\r\n    }: {\r\n        top: number; left: number; width: number; height: number; open: boolean\r\n    } = $props();\r\n</script>\r\n\r\n{#if open}\r\n    <div\r\n            transition:fade={{ duration: 300 }}\r\n            class=\"fixed z-[9998] pointer-events-none transition-all duration-500 ease-in-out\"\r\n            style=\"\r\n            top: {top}px;\r\n            left: {left}px;\r\n            width: {width}px;\r\n            height: {height}px;\r\n            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7);\r\n            border-radius: 6px;\r\n        \"\r\n    ></div>\r\n{/if}",
			"type": "registry:ui",
			"target": "walkthrough/walkthrough-spotlight.svelte"
		},
		{
			"content": "import { getContext, setContext } from \"svelte\";\r\n\r\nconst WALKTHROUGH_KEY = Symbol(\"walkthrough\");\r\n\r\nexport type Step = {\r\n    target: string; // ID of the element\r\n    title: string;\r\n    description: string;\r\n    position?: \"top\" | \"bottom\" | \"left\" | \"right\";\r\n};\r\n\r\ntype WalkthroughContext = {\r\n    isOpen: () => boolean;\r\n    currentStepIndex: () => number;\r\n    currentStep: () => Step | undefined;\r\n    isLastStep: () => boolean;\r\n    next: () => void;\r\n    prev: () => void;\r\n    close: () => void;\r\n};\r\n\r\nexport function setWalkthroughContext(ctx: WalkthroughContext) {\r\n    setContext(WALKTHROUGH_KEY, ctx);\r\n}\r\n\r\nexport function getWalkthroughContext() {\r\n    return getContext<WalkthroughContext>(WALKTHROUGH_KEY);\r\n}",
			"type": "registry:ui",
			"target": "walkthrough/ctx.ts"
		},
		{
			"content": "import Walkthrough from \"./walkthrough.svelte\";\r\nexport { Walkthrough };",
			"type": "registry:ui",
			"target": "walkthrough/index.ts"
		}
	]
}